#!/usr/bin/env ruby
# vim: set ts=2 sw=2

# This tool is a tool to generate user data and validate that data against a
# list of checksums. I aim to make it fully automate-able as well as easy
# enough for anyone to use.

require 'readline'
include Readline
require 'fileutils'
srand()

# print the usage menu for interactive mode
def print_menu
  print "\n"
  puts "Menu: "
  puts "gen\tGenerate data"
  puts "mksum\tGenerate checksums for data"
  puts "verify\tVerify data"
  puts "quit\tQuit"
  print "\n"
end

# menu to generate the large amounts of data interactive mode
def generate_data_interactively
  print "\n"
  puts "-- Press CTRL+C to cancel --"
  print "\n"

  begin
    puts "Where do you want to create the data? "
    loc = readline("> ", TRUE)

    puts "Minimum filesize in kilobytes? "
    minsize = readline("# ", TRUE).to_i

    puts "Maximum filesize in kilobytes? "
    maxsize = readline("# ", TRUE).to_i

    puts "Number of files? "
    filenum = readline("# ", TRUE).to_i

    puts "Number of directories? "
    dirnum = readline("# ", TRUE).to_i
  rescue Interrupt
    return
  rescue
    STDERR.puts "Error: #{$!}"
  end

  # files per directory
  fpd = filenum / dirnum

  print "\n"
  print "[+] Okay, let me make sure I get it right:\nYou want #{filenum} total "
  print "files to be put in #{dirnum} subdirectories, with sizes ranging "
  print "between #{minsize}kb and #{maxsize}kb."
  print "\n\n"
  print "This will put around #{fpd} files in each directory.\n"
  print "All these files will be in the '#{loc}' directory."
  print "\n\n"
  print "Are these settings correct?\n"

  begin
    confirm = readline("[y/n] ", TRUE)
  rescue Interrupt
    return
  rescue
    STDERR.puts "Error: #{$!}"
  end
  
  if confirm != "y"
    puts "Abort!"
    return
  end

  generate_data(loc, minsize, maxsize, filenum, dirnum)
end

# actually generate the data
def generate_data(loc, minsize, maxsize, filenum, dirnum)
  fpd = filenum / dirnum
  print "\n"
  puts "[+] Checking paramaters..."
  if !File.exist?(loc) and !File.directory?(loc)
    puts "\n[Error] File #{loc} doesn't exist or isn't a directory!"
    return
  end
  if minsize < 1 or maxsize < minsize or filenum < 1
    puts "\n[Error] I can't work with sizes like that!"
    return
  end
  if dirnum > filenum
    puts "\n[Error] Can't have more directories than files!"
    return
  end
  puts "[+] Checking to make sure you have dd..."
  system("which dd > /dev/null")
  if ($? != 0)
    puts "\n[Error] I can't find the 'dd' program!"
    return
  end

  puts "[+] Generating data..."

  fncount = 0

  for i in 0..(dirnum-1) do
    dname = loc + "/dir" + ("0"*(8-(i.to_s.length))).to_s + i.to_s
    puts "[+] Making #{dname} and populating it with data..."
    if File.directory?(dname)
      puts "directory #{dname} already exists, skipping"
    else
      begin
        FileUtils.mkdir_p(dname)
      rescue
        puts "[Error] Creating directory: #{$!}"
      end
    end

    for j in 0..(fpd-1) do
      fname = dname + "/file" + ("0"*(8-(fncount.to_s.length))).to_s + fncount.to_s
      fncount = fncount + 1
      fsize = minsize + rand(maxsize-minsize)
      begin
        system("dd if=/dev/urandom of=#{fname} bs=1024 count=#{fsize} 2> /dev/null")
      rescue
        puts "[Error] Creating file: #{$!}"
      end
      if $? != 0
        puts "There was an error creating '#{fname}'"
      end

    end

  end

  puts "[+] Done generating data."

end

# create checksums for data
def create_checksums

end

# verify data checksums
def verify_checksums

end


# Main interaction loop
if ARGV.size < 1
  # interactive mode
  loop {
    print_menu()
    begin
      cmd = readline("ds> ", TRUE)
    rescue Interrupt 
      exit(0)
    rescue
      STDERR.puts "Error: #{$!}"
    end

    case cmd
      when "quit":
        puts "Bye!"
        exit(0)
      when "q":
        puts "Bye!"
        exit(0)
      when "gen":
        generate_data_interactively()
      when "mksum":
        create_checksums()
      when "verify":
        verify_checksums()
    end
  }
  exit(0)
end

puts "Usage: "  
